(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{134:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var o=n(0),i=n.n(o);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),u=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=u(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},h=i.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=u(n),h=o,m=p["".concat(s,".").concat(h)]||p[h]||d[h]||a;return n?i.a.createElement(m,r(r({ref:t},l),{},{components:n})):i.a.createElement(m,r({ref:t},l))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=h;var r={};for(var c in t)hasOwnProperty.call(t,c)&&(r[c]=t[c]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var l=2;l<a;l++)s[l]=n[l];return i.a.createElement.apply(null,s)}return i.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},78:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return u}));var o=n(3),i=n(7),a=(n(0),n(134)),s={id:"nondeterministic",title:"Non-deterministic Testing",slug:"non-deterministic-testing.html"},r={unversionedId:"assertions/nondeterministic",id:"assertions/nondeterministic",isDocsHomePage:!1,title:"Non-deterministic Testing",description:"Sometimes you have to work with code that is non-deterministic in nature. This is never the preferred scenario, but if you have no choice then",source:"@site/docs/assertions/nondeterministic_testing.md",slug:"/assertions/non-deterministic-testing.html",permalink:"/docs/assertions/non-deterministic-testing.html",editUrl:"https://github.com/kotest/kotest/docs/assertions/nondeterministic_testing.md",version:"current",sidebar:"assertions",previous:{title:"Soft Assertions",permalink:"/docs/assertions/soft-assertions.html"},next:{title:"Inspectors",permalink:"/docs/assertions/inspectors.html"}},c=[{value:'Eventually <a name="eventually"></a>',id:"eventually",children:[{value:"Examples",id:"examples",children:[]}]},{value:'Continually <a name="continually"></a>',id:"continually",children:[]},{value:'Retry <a name="retry"></a>',id:"retry",children:[]}],l={rightToc:c};function u(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(a.b)("wrapper",Object(o.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Sometimes you have to work with code that is non-deterministic in nature. This is never the preferred scenario, but if you have no choice then\nKotest has you covered with several functions that cater to tests which may take some time to pass."),Object(a.b)("h2",{id:"eventually"},"Eventually ",Object(a.b)("a",{name:"eventually"})),Object(a.b)("p",null,'When testing non-deterministic code, a common use case is "I expect this code to pass after a short period of time". For example, if you\nwere testing a IO operation, you might need to wait until the IO operation has flushed.'),Object(a.b)("p",null,"Sometimes you can do a Thread.sleep but this is isn't ideal as you need to set a sleep threshold high enough so that it won't expire prematurely on a slow machine.\nPlus it means that your test will sit around waiting on the timeout even if the code completes quickly on a fast machine."),Object(a.b)("p",null,"Or you can roll a loop and sleep and retry and sleep and retry, but this is just boilerplate slowing you down."),Object(a.b)("p",null,"Another common approach is to use countdown latches and this works fine if you are able to inject the latches in the appropriate places but it isn't always\npossible to have the code under test trigger a latch."),Object(a.b)("p",null,"As an alternative, Kotest provides the ",Object(a.b)("inlineCode",{parentName:"p"},"eventually")," function which will periodically\ntest the code until it either passes, or the timeout is reached. This is perfect for nondeterministic code."),Object(a.b)("h3",{id:"examples"},"Examples"),Object(a.b)("h4",{id:"simple-example"},"Simple example"),Object(a.b)("p",null,"Let's assume that we send a message to an asynchronous service. After the message is processed, a new row is inserted into user table."),Object(a.b)("p",null,"We can check this behaviour with our ",Object(a.b)("inlineCode",{parentName:"p"},"eventually")," function."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-kotlin"}),'class MyTests : ShouldSpec() {\n  init {\n    should("check if user repository has one row after message is sent") {\n      sendMessage()\n      eventually(5.seconds) {\n        userRepository.size() shouldBe 1\n      }\n    }\n  }\n}\n')),Object(a.b)("h4",{id:"exceptions"},"Exceptions"),Object(a.b)("p",null,"By default, ",Object(a.b)("inlineCode",{parentName:"p"},"eventually")," will ignore any exception that is thrown inside the function (note, that means it won't catch ",Object(a.b)("inlineCode",{parentName:"p"},"Error"),").\nIf you want to be more specific, you can tell ",Object(a.b)("inlineCode",{parentName:"p"},"eventually")," to ignore specific exceptions and any others will immediately fail the test."),Object(a.b)("p",null,"Let's assume that our example from before throws a ",Object(a.b)("inlineCode",{parentName:"p"},"UserNotFoundException")," while the user is not found in the database.\nIt will eventually return the user when the message is processed by the system."),Object(a.b)("p",null,"In this scenario, we can explicitly skip the exception that we expect to happen until the test passed, but any other exceptions would\nnot be ignored. Note, this example is similar to the former, but if there was some other error, say a ConnectionException for example, this would cause\nthe eventually block to immediately exit with a failure message."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-kotlin"}),'class MyTests : ShouldSpec() {\n  init {\n    should("check if user repository has one row") {\n      eventually(5.seconds, UserNotFoundException::class.java) {\n        userRepository.findBy(1) shouldNotBe null\n      }\n    }\n  }\n}\n')),Object(a.b)("h2",{id:"continually"},"Continually ",Object(a.b)("a",{name:"continually"})),Object(a.b)("p",null,"As the dual of eventually, ",Object(a.b)("inlineCode",{parentName:"p"},"continually")," allows you to assert that a block of code suceeds, and continues to succeed, for a period of time.\nFor example you may want to check that a http connection is kept alive for 60 seconds after the last packet has been received.\nYou could sleep for 60 seconds, and then check, but if the connection was terminated after 5 seconds, your test will sit idle for a further 55 seconds before then failing.\nBetter to fail fast."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-kotlin"}),'class MyTests : ShouldSpec() {\n  init {\n    should("pass for 60 seconds") {\n      continually(60.seconds) {\n        // code here that should succeed and continue to succeed for 60 seconds\n      }\n    }\n  }\n}\n')),Object(a.b)("p",null,"The function passed to the ",Object(a.b)("inlineCode",{parentName:"p"},"continually")," block is executed every 10 milliseconds. We can specify the poll interval if we prefer:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-kotlin"}),'class MyTests: ShouldSpec() {\n  init {\n    should("pass for 60 seconds") {\n      continually(60.seconds, 5.seconds) {\n        // code here that should succeed and continue to succeed for 60 seconds\n      }\n    }\n  }\n}\n')),Object(a.b)("h2",{id:"retry"},"Retry ",Object(a.b)("a",{name:"retry"})),Object(a.b)("p",null,"Retry is similar to eventually, but rather than attempt a block of code for a period of time, it attempts a block of code a maximum number of times.\nWe still provide a timeout period to avoid the loop running for ever."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-kotlin"}),'class MyTests: ShouldSpec() {\n  init {\n    should("retry up to 4 times") {\n      retry(4, 10.minutes) {\n      }\n    }\n  }\n}\n')),Object(a.b)("p",null,"Additional options include the delay between runs, a multiplier to use exponential delays, and an exception class if we only want to\nrepeat for certain exceptions and fail for others."))}u.isMDXComponent=!0}}]);